Базовые операторы сравнения 
$a == $b 	"Равно"                 TRUE если $a равно $b после преобразования типов.
$a === $b 	"Тождественно равно"    TRUE если $a равно $b и имеет тот же тип.
$a != $b 	"Не равно"              TRUE если $a не равно $b после преобразования типов.
$a <> $b 	"Не равно"              TRUE если $a не равно $b после преобразования типов.
$a !== $b 	"Тождественно не равно" TRUE если $a не равно $b, или они разных типов.
$a < $b 	"Меньше"                TRUE если $a строго меньше $b.
$a > $b 	"Больше"                TRUE если $a строго больше $b.
$a <= $b 	"Меньше или равно"      TRUE если $a меньше или равно $b.
$a >= $b 	"Больше или равно"      TRUE если $a больше или равно $b.
$a <=> $b 	"spaceship"             Число типа integer меньше, больше или равное нулю, когда $a соответственно меньше, больше или равно $b. Доступно c PHP 7. 

Тернарный оператор

<?php
// Пример использования тернарного оператора
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// Приведенный выше код аналогичен следующему блоку с использованием if/else
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}

?>

Null coalescing

<?php
// Пример использования оператора
$action = $_POST['action'] ?? 'default';

// Пример выше аналогичен следующему коду
if (isset($_POST['action'])) {
    $action = $_POST['action'];
} else {
    $action = 'default';
}

?>

 Оператор instanceof используется для определения того, является ли текущий объект экземпляром указанного класса. 
<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>


1) null или string и string => NULL преобразуется в "", числовое или лексическое сравнение
2)bool или null и что угодно  => Преобразуется в тип bool, FALSE < TRUE
3)object и object => Встроенные классы могут определять свои собственные правила сравнения, объекты разных классов не сравниваются, про сравнение объектов одного класса см. Сравнение объекта
4)string, resource или number и string, resource или number => Строки и ресурсы переводятся в числа, обычная математика
array и array => Массивы с меньшим числом элементов считаются меньше, если ключ из первого операнда не найден во втором операнде - массивы не могут сравниваться, иначе идет сравнение соответствующих значений (см. пример ниже)
array и что угодно => тип array всегда больше
object и что угодно => тип object всегда больше

В случае, если вы сравниваете число со строкой или две строки, содержащие числа, каждая строка будет преобразована в число, и сравниваться они будут как числа. Эти правила также распространяются на оператор switch. Преобразование типов не происходит при использовании === или !== так как в этом случае кроме самих значений сравниваются еще и типы. 


<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // Эта ветка никогда не будет достигнута, так как "a" уже сопоставленно с 0
    echo "a";
    break;
}
?>



<?php  
// Целые
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1
 
// С плавающей точкой
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1
 
// Строки
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
 
echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1
 
// Массивы
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1
 
// Объекты
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 0
 
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "c"]; 
echo $a <=> $b; // -1
 
$a = (object) ["a" => "c"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 1
 
// сравниваются не только значения; ключи должны соответствовать
$a = (object) ["a" => "b"]; 
$b = (object) ["b" => "b"]; 
echo $a <=> $b; // 1

?>



<?php
// Так сравниваются массивы при сравнении стандартными операторами
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // не могут быть сравнимы
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
